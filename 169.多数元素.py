#
# @lc app=leetcode.cn id=169 lang=python3
#
# [169] 多数元素
#

# @lc code=start
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        #摩尔投票法,时间复杂度O(n),空间复杂度O(1)
        ''''''
        摩尔投票法（Boyer-Moore Majority Vote Algorithm）的核心思想是在每一步中，维护一对当前的候选主元素和一个计数器。遍历整个数组，对于每一个元素，如果计数器为零，我们把这个元素设为候选主元素并把计数器设置为1，如果计数器不为零，我们对计数器进行如下操作：如果这个元素等于当前候选主元素，我们把计数器加1，否则把计数器减1。

算法之所以有效，关键在于多数元素的定义。多数元素是指一个元素出现的次数超过总数的一半。因此，如果把多数元素看作+1，把其他元素看作-1，那么整个数组的和一定是大于0的。这是因为多数元素的数量超过了其他所有元素的总和。

在摩尔投票法中，每当计数器变为0，我们就把当前元素设为候选主元素。如果这个候选主元素是真正的多数元素，那么在后面的遍历中，它的计数器一定会被加回来并且大于0，这是因为它的数量超过了其他所有元素的总和。而其他的非多数元素，由于它们的数量小于总数的一半，即使它们被设为候选主元素，也不可能在后面的遍历中把计数器加回来并且大于0。

这样，经过一次遍历后，剩下的候选主元素一定是多数元素。如果序列中没有多数元素，那么算法可能不会返回有效的结果，因此在使用该算法的场合中，通常会保证序列存在多数元素，或者在算法运行后再次检查算法返回的候选元素是否真的是多数元素。
        ''''''
        count = 0
        candidate = None
        for num in nums:
            if count == 0:
                candidate = num
            if num == candidate:
                count+=1
            else:
                count-=1
        return candidate
    
# @lc code=end

